<!--
 * @Description: 文件描述
 * @version: 1.0
 * @Author: 吴东宇
 * @Date: 2022-08-23 11:15:56
 * @LastEditors: 吴东宇
 * @LastEditTime: 2022-08-24 15:36:42
-->
# 进程和线程
> 从本质上说，进程和线程都是 CPU 工作时间片的一个描述：
> - 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。
> - 线程是进程中的更小单位，描述了执行一段指令所需的时间。
## 并行
> 使用多线程同一时刻处理多个任务就是并行
## 进程
- 一个进程就是一个程序的运行实例。启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程
## 线程
- 线程不能单独存在，而是由进程启动和管理
## 进程和线程的关系
1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃
2. 线程之间共享进程中的数据
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存
4. 进程之间的内容相互隔离
> 进程间的通讯使用IPC机制
## 进程和线程的区别
- `进程`可以看做独立应用，`线程`不能
- `资源`：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
- `通信方面`：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 IPC 进行进程间通信。
- `调度`：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- `系统开销`：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

# 浏览器架构
## 早期单进程浏览器
> 单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等
### 单进程浏览器的问题
1. `不稳定` 一个线程崩溃整个浏览器都跟着崩溃
2. `不流畅` 页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行
3. `不安全` 页面脚本可以通过浏览器的漏洞来获取系统权限从而引发安全问题

## 多进程浏览器
> 最新的Chrome浏览器包含`1个浏览器主进程,1个网络进程,1个GPU进程,多个插件进程和多个渲染进程`
- `浏览器进程`：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- `渲染进程`：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- `GPU 进程`：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- `网络进程`：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- `插件进程`：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
### 多进程浏览器的问题
1. `更高的资源占用`。因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。
2. `更复杂的体系架构`。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了
## 浏览器渲染进程的线程
> 注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。
- `GUI渲染线程`
    负责渲染浏览器页面，构架htmlDOM树，CSSOM树，渲染树和绘制页面，单页面因为某些操作需要回流或者重绘时就会执行该线程
- `JS引擎线程`
    JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；
- `事件触发线程`
    事件触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；
- `定时器触发进程`
    定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；
    注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。
- `异步http请求线程`
    - XMLHttpRequest连接后通过浏览器新开一个线程请求；
    - 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；

# HTTP请求流程
1. 构建请求
2. 查找缓存
3. 准备ip地址和端口
4. 等待TCP队列
5. 三次握手建立TCP连接
6. 浏览器发送请求行，请求头，请求体
7. 服务器返回响应头，响应行，响应体
8. 判断是否需要重定向，如果响应行状态码301需要根据响应头的Location重定向重新发送请求
9. 判断是否断开连接 存在请求头Connection:Keep-Alive则继续保持连接 否则四次挥手断开TCP连接

# 从输入URL到页面展示这中间发生了什么
- 用户输入url并回车
- 浏览器进程检查url，组装协议，构成完整的url
- 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
- 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
- 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
    - 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
    - 利用ip地址和服务器建立tcp连接
    - 构建请求头信息
    - 发送请求头信息
    - 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
- 网络进程解析响应流程；
    - 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
    - 200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
- 准备渲染进程
    - 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
- 传输数据、更新状态
    - 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
    - 渲染进程接收完数据后，向浏览器发送“确认提交”
    - 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面

